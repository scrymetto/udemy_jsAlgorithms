#JavaScript Algorithms and Data Structures Masterclass

(https://www.udemy.com/course/js-algorithms-and-data-structures-masterclass/)

##Паттерны
###Frequency counter
Типичная задача - найти анаграмы. Вместо использования цикла в цикле, заводим переменную `obj`, проходим циклом первое слово/массив, каждый элемент/буква - ключ в `obj`. Если такой ключ есть, увеличиваем значение на 1. Затем проходимся вторым циклом по второму слову/массиву - проверяем в `obj` наличие ключа (`obj[arr2[i]]`). Если его нет - возвращаем `false`, иначе отнимаем единицу. 

###Multiple pointers
Типичная задача - найти пару элементу массива/букве в строке (например, найти первую пару значений массива, сумма которых = 0). **Главное условие** - массив должен быть **отсортирован**! Заводим 2 переменные - `let left = 0` и `let right = arr.length-1`. Заводим цикл, в котором проверяем, чему равно сумма этих переменных. Если она больше искомого, сдвигаем `right` на 1 влево (массив отсортирован => следующее значение будет меньше). Если значение меньше искомого, сдвигаем `left` на один вправо. И так до тех пор, пока `left` меньше `right`. Если значение суммы совпало с искомым, возвращаем пару, если нет - возвращаем `null`. Основная идея - не заводить второй цикл, а двигаться по массиву, начиная от разных элементов, одновременно.

###Sliding window
Типичная задача - найти подмассив заданной длины, сумма элементов которого будет максимальной в данном массиве. Основная идея - не заводить второй цикл и пересчитывать всю сумму заново, а двигаться "окном" - найти сумму заданного количества элементов, двигаться вправо, вычитая первый элемент и приплюсовывая следующий. 

###Divide and conquer 
Типичная задача - найти индекс нужного значения в **отсортированном** массиве. Вместо того, чтобы идти по массиву от начала до конца, заводим 3 переменные - `let start = 0`, `let end = arr.length-1` и `let middle`, которая равна количеству элементов, поделенное на 2, предполагая, что это и есть индекс искомого элемента. Если `arr[middle]` больше искомого, устанавливаем `end = middle-1` (так как значение `middle` уже проверили), если меньше, то `start = middle+1`. Повторяем до тех пор, пока `start < end`. 

##Сортировки

###Bubble
Заводим 2 цикла. Сравниваем попарно элементы массива во втором цикле - 0 и 1, затем 1 и 2, затем 2 и 3, и т.д. Тот элемент, который больше, получает больший индекс. Дошли до конца -> запускаем следующую итерацию первого цикла и так до конца. **Оптимизация** - если за весь проход не было перестановок, выходим из цикла. Для этого заводим переменную boolean, которая по умолчанию = true. Если перестановка была, изменяем ее на false. Каждую итерацию первого цикла проверяем условие `if ( boolean ) { break }`

###Selection
Заводим цикл, объявляем переменную `min`, равную `i`, которая по умолчанию считается индексом минимального значения массива. Заводим второй цикл, в котором проверяем, меньше ли следующий элемент, чем `arr[min]`. Если да, то значение `min` становится равно `j`. Таким образом находится наименьший элемент массива. На выходе из второго цикла проверяется, изменилось ли значение переменной `min`. Если да, то элементы `arr[i]` и `arr[min]` меняются местами. 

###Insertion
Объявляем переменную `currentValue`. Заводим цикл (начиная с **первого** элемента (не нулевого!)), в котором присваиваем `currentValue` значение `arr[i]`. Исходим из того, что левая часть массива (до `i`) - уже отсортирована. Заводим второй цикл, в котором счетчик массива начинается со значения `i-1`. При этом должно выполняться условие, что текущее значение **меньше** `currentValue` (так как массив в левой части отсортирован, и если текущее значение больше, значит условие сортировки и так соблюдено и перемещать элемент никуда не нужно). Если `currentValue` меньше последнего в левой части - выполняем `arr[j+1] = arr[j]` - таким образом 'сдвигаем' отсортированный массив на 1 индекс для вставки в него `currentValue` - и идем дальше по второму циклу. Когда условие не выполнится, то в значении `j` у нас будет сохранен индекс элемента, значение которого меньше `currentValue` => выполняем `arr[j+1]=currentValue` - вставляем нужный элемент после него. После этого левая часть массива снова отсортирована, двигаемся по первому циклу дальше.
